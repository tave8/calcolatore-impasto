/**
 * This class must accomodate the following use cases:
 *
 * # Recipe Calculator
 *
 * ## USE CASES
 *
 * ### RECIPE -> INGREDIENT PROPORTIONS (calcProportions)
 *
 * I have the recipe, I want the ingredient proportions
 *
 * ### 1 INGREDIENT -> OTHER INGREDIENTS (calcFromIngredient)
 *
 * I have one ingredient and its quantity, I want the quantity of other ingredients
 *
 * ### TOTAL RECIPE -> ALL INGREDIENTS (calcFromTot)
 *
 * I have the total quantity of the recipe, I want the quantity of all ingredients
 *
 */

class Recipe {
  constructor(recipeName, ingredientsList) {
    this.name = recipeName;
    this.ingredients = [];
    // this contains all recipe instances (industry term) that will be
    // generated by each recipe instances (programming term)
    // when the user provices a "recipe", that's not the actual recipe,
    // that's a "recipe instance". a recipe instance is a recipe with the quantities,
    // whereas a recipe is the ingredients with their proportions
    this.instances = [];
    this.addIngredients(ingredientsList);
    // important: adding the first recipe instance must come BEFORE
    // calculating the proportions. because calculating the recipe proportions
    // depends on the "recipe" (so the recipe instance) that the user provides,
    // then we must first add this recipe instance, and then
    // we calculate the proportions based on that
    this.addInstance(ingredientsList);
    this._calcProportions();
  }

  addIngredients(ingredientsList) {
    for (let i = 0; i < ingredientsList.length; i++) {
      const ingredientInfo = ingredientsList[i];
      this.addIngredient(ingredientInfo);
    }
  }

  addIngredient(ingredientInfo) {
    const ingredient = new Ingredient(ingredientInfo);
    this.ingredients.push(ingredient);
    return ingredient;
  }

  /**
   * Adds and returns the newly created recipe instance.
   */
  addInstance(ingredientsList) {
    const recipeInstance = new RecipeInstance(ingredientsList, this);
    this.instances.push(recipeInstance);
    return recipeInstance;
  }

  calcFromIngredient({ name: ingredientKnown, quantity: quantityKnown }) {
    const newRecipeInstance = this.addInstance([]);
    //   trova proporzione dell'ingrediente noto, dalle proporzioni personalizzate
    const proportionKnown = this._findProportionOfIngredient(ingredientKnown);
    // visto che il totale delle proporzioni sarà sempre 1, allora
    // la proporzione rimanente si ottiene sottraendo  1 - proporzioneNota
    const proportionKnownRemaining = 1 - proportionKnown;
    // la quantita rimanente del totale
    // si basa sulla seguente proporzione
    // quantitaNota : quantitaRimanente = proporzioneNota : proporzioneNotaRimanente
    // esempio:
    // 10 g di sale stanno alla quantità di impasto che rimane, come la proporzione del sale (nel totale impasto)
    // sta al totale delle proporzioni degli altri ingredienti
    const quantityRemaining = (quantityKnown * proportionKnownRemaining) / proportionKnown;
    // alla fine, dalla quantita nota di un ingrediente, e dalle proporzioni della ricetta,
    // si ricava la quantità totale di questo (nuovo?) impasto, non di quello dato
    // prima dall'utente come input
    const totNewQuantity = quantityKnown + quantityRemaining;

    for (let i = 0; i < this.ingredients.length; i++) {
      // always refer to the real ingredient (so the proportion)
      const ingredient = this.ingredients[i];
      // moltiplicando la quantità totale con la proporzione del singolo ingrediente,
      // ricavo finalmente la quantità di ogni altro ingrediente, oltre all'ingrediente dato
      const newQuantity = totNewQuantity * ingredient.proportion;
      // arrotondamenti e non
      newRecipeInstance.addIngredient({ quantity: newQuantity }, ingredient);
    }

    return newRecipeInstance;
  }

  calcFromTot(totIngredientsKnown) {
    const newRecipeInstance = this.addInstance([]);
    for (let i = 0; i < this.ingredients.length; i++) {
      const ingredient = this.ingredients[i];
      // la quantità dell'ingrediente si ottiene moltiplicando
      // la quantità totale (che è nota) con la proporzione
      // del singolo elemento
      const newQuantity = totIngredientsKnown * ingredient.proportion;
      newRecipeInstance.addIngredient({ quantity: newQuantity }, ingredient);
    }
    return newRecipeInstance;
  }

  _calcProportions() {
    // to compute the proportions, the first recipe instance
    // is taken
    const recipeInstance = this.instances[0];
    if (recipeInstance === undefined) {
      throw Error("Cannot compute recipe proportions " + "if there's no recipe instance.");
    }

    // how many ingredients are there
    for (let i = 0; i < recipeInstance.ingredients.length; i++) {
      const ingredientInstance = recipeInstance.ingredients[i];
      const ingredient = ingredientInstance.ingredient;
      // la proporzione del singolo ingrediente è data dalla sua quantita
      // rispetto alla quantità totale
      const proportion = ingredientInstance.quantity / recipeInstance.totIngredients;

      ingredient._setProportion(proportion);
      ingredient._setPercentage(proportion);
    }
    return this;
  }

  _findProportionOfIngredient(ingredientName) {
    for (let i = 0; i < this.ingredients.length; i++) {
      const ingredient = this.ingredients[i];
      // se trovo l'ingrediente che mi interessa
      if (ingredient.name === ingredientName) {
        return ingredient.proportion;
      }
    }
    throw Error("Non è stato trovato nessuna proporzione per l'ingrediente dato.");
  }
}

class RecipeInstance {
  constructor(ingredientsList, recipe) {
    this.recipe = recipe;
    this.ingredients = [];
    this.totIngredients = 0;
    this.addIngredients(ingredientsList, recipe);
  }

  addIngredients(ingredientsList, recipe) {
    for (let i = 0; i < ingredientsList.length; i++) {
      const ingredientInfo = ingredientsList[i];
      const ingredient = recipe.ingredients[i];
      this.addIngredient(ingredientInfo, ingredient);
    }
  }

  addIngredient(ingredientInfo, ingredient) {
    const ingredientInstance = new IngredientInstance(ingredientInfo, ingredient);
    this.ingredients.push(ingredientInstance);
    this.totIngredients += ingredientInstance.quantity;
    return ingredientInstance;
  }

  calcTotIngredients() {
    this.totIngredients = 0;
    for (let i = 0; i < this.ingredients.length; i++) {
      const ingredientInstance = this.ingredients[i];
      this.totIngredients += ingredientInstance.quantity;
    }
    return this;
  }
}

class Ingredient {
  constructor(info) {
    this.name = info.name;
    this.proportion = info.proportion;
  }

  getProportion() {
    return this.proportion;
  }

  getProportionRounded() {
    return this._roundProportion(this.proportion);
  }

  getPercentage() {
    return this.proportion * 100;
  }

  getPercentageRounded() {
    return this._roundPercentage(this.proportion * 100);
  }

  _setProportion(proportion) {
    this.proportion = proportion;
  }

  _setPercentage(proportion) {
    this.percentage = proportion * 100;
  }

  // HELPERS

  _roundNumber(x, nDigits) {
    return parseFloat(x.toFixed(nDigits));
  }

  _roundProportion(x) {
    return this._roundNumber(x, 4);
  }

  _roundPercentage(x) {
    return this._roundNumber(x, 2);
  }

  _roundQuantity(x) {
    return this._roundNumber(x, 2);
  }

  genRandNum(limit = 10000000) {
    return Math.floor(Math.random() * limit);
  }
}

class IngredientInstance {
  constructor(info, ingredient) {
    this.quantity = info.quantity;
    this.ingredient = ingredient;
  }
}

// USAGE

// the actual recipe
const recipeFatimasBread = new Recipe("Fatima's Bread", [
  { name: "farina v300", quantity: 430 },
  { name: "farina semola", quantity: 20 },
  { name: "acqua", quantity: 315 },
  { name: "olio", quantity: 15 },
  { name: "sale", quantity: 15 },
  { name: "malto", quantity: 6 },
  { name: "zucchero", quantity: 6 },
  { name: "lievito birra", quantity: 1 },
]);

// recipe instance
const recipeFatimasBreadFromXWheat = recipeFatimasBread.calcFromIngredient({
  name: "farina v300",
  quantity: 800,
});

// recipe instance
const recipeFatimasBreadFromXTot = recipeFatimasBread.calcFromTot(1000);

console.log(recipeFatimasBread);
console.log(recipeFatimasBreadFromXWheat);
console.log(recipeFatimasBreadFromXTot);
