/**
 * This class must accomodate the following use cases:
 *
 * # Recipe Calculator
 *
 * ## USE CASES
 *
 * ### RECIPE -> INGREDIENT PROPORTIONS (calcProportions)
 *
 * I have the recipe, I want the ingredient proportions
 *
 * ### 1 INGREDIENT -> OTHER INGREDIENTS (calcFromIngredient)
 *
 * I have one ingredient and its quantity, I want the quantity of other ingredients
 *
 * ### TOTAL RECIPE -> ALL INGREDIENTS (calcFromTot)
 *
 * I have the total quantity of the recipe, I want the quantity of all ingredients
 *
 */

class Recipe {
  constructor(recipeName, ingredientsList) {
    this.name = recipeName;
    this.ingredients = [];
    // this contains all recipe instances (industry term) that will be
    // generated by each recipe instances (programming term)
    // when the user provices a "recipe", that's not the actual recipe,
    // that's a "recipe instance". a recipe instance is a recipe with the quantities,
    // whereas a recipe is the ingredients with their proportions
    this.instances = [];
    // the initial recipe that the user provides
    this.coreInstance = new RecipeInstance([], this);

    this.addIngredients(ingredientsList);
  }

  addIngredients(ingredientsList) {
    for (let i = 0; i < ingredientsList.length; i++) {
      const ingredientInfo = ingredientsList[i];
      this.addIngredient(ingredientInfo);
    }
  }

  /**
   * Every time a new ingredient is added, the proportions will be re-computed.
   */
  addIngredient(ingredientInfo) {
    // check: the name of the ingredient must be unique

    const ingredient = new Ingredient(ingredientInfo);
    const ingredientInstance = new IngredientInstance(ingredientInfo, ingredient, this.coreInstance);
    this.ingredients.push(ingredient);
    this.coreInstance.ingredients.push(ingredientInstance);
    // important: you must compute the total ingredients,
    // before computing the proportions. this is because
    // the proportion of the ingredient, depends on the total quantity
    // of the core recipe instance
    // every time a new ingredient is added to the core recipe instance,
    // then you must update the ingredient proportions,
    // because there will be new rations, proportions, between ingredients
    this._calcProportions();
    return ingredient;
  }

  /**
   * Every time an ingredient is removed, the proportions will be re-computed.
   */
  removeIngredient(ingredientName) {
    let ingredientFound = false;
    for (let i = 0; i < this.ingredients.length; i++) {
      const ingredient = this.ingredients[i];
      if (ingredientName === ingredient.name) {
        ingredientFound = true;
        this.ingredients.splice(i, 1);
        this.coreInstance.ingredients.splice(i, 1);
      }
    }
    if (!ingredientFound) {
      throw Error(`No ingredient '${ingredientName}' was found.`)
    }
    this._calcProportions();
  }

  /**
   * Adds and returns the newly created recipe instance.
   */
  // addInstance(ingredientsList) {
  //   const recipeInstance = new RecipeInstance(ingredientsList, this);
  //   this.instances.push(recipeInstance);
  //   return recipeInstance;
  // }

  calcFromIngredient({ name: ingredientKnown, quantity: quantityKnown }) {
    const newRecipeInstance = this.addInstance([]);
    //   trova proporzione dell'ingrediente noto, dalle proporzioni personalizzate
    const proportionKnown = this._findProportionOfIngredient(ingredientKnown);
    // visto che il totale delle proporzioni sarà sempre 1, allora
    // la proporzione rimanente si ottiene sottraendo  1 - proporzioneNota
    const proportionKnownRemaining = 1 - proportionKnown;
    // la quantita rimanente del totale
    // si basa sulla seguente proporzione
    // quantitaNota : quantitaRimanente = proporzioneNota : proporzioneNotaRimanente
    // esempio:
    // 10 g di sale stanno alla quantità di impasto che rimane, come la proporzione del sale (nel totale impasto)
    // sta al totale delle proporzioni degli altri ingredienti
    const quantityRemaining = (quantityKnown * proportionKnownRemaining) / proportionKnown;
    // alla fine, dalla quantita nota di un ingrediente, e dalle proporzioni della ricetta,
    // si ricava la quantità totale di questo (nuovo?) impasto, non di quello dato
    // prima dall'utente come input
    const totNewQuantity = quantityKnown + quantityRemaining;

    for (let i = 0; i < this.ingredients.length; i++) {
      // always refer to the real ingredient (so the proportion)
      const ingredient = this.ingredients[i];
      // moltiplicando la quantità totale con la proporzione del singolo ingrediente,
      // ricavo finalmente la quantità di ogni altro ingrediente, oltre all'ingrediente dato
      const newQuantity = totNewQuantity * ingredient.proportion;
      // arrotondamenti e non
      newRecipeInstance.addIngredient({ quantity: newQuantity }, ingredient);
    }

    return newRecipeInstance;
  }

  calcFromTot(totIngredientsKnown) {
    const newRecipeInstance = this.addInstance([]);
    for (let i = 0; i < this.ingredients.length; i++) {
      const ingredient = this.ingredients[i];
      // la quantità dell'ingrediente si ottiene moltiplicando
      // la quantità totale (che è nota) con la proporzione
      // del singolo elemento
      const newQuantity = totIngredientsKnown * ingredient.proportion;
      newRecipeInstance.addIngredient({ quantity: newQuantity }, ingredient);
    }
    return newRecipeInstance;
  }

  /**
   *
   * The function that computes the proportions.
   * The proportion computation is based on the
   * core instance recipe, which is initially provided by the user,
   * as well as being able to be updated, by adding or removing ingredients.
   */
  _calcProportions() {
    // make sure the core instance always has the correct total,
    // otherwise proportions will not be correct
    this.coreInstance.calcTotIngredients();
    // console.log(this.coreInstance)
    // return
    // to compute the proportions, consider the "core recipe instance"
    // which is the recipe that the user initially provided, as well as
    // any additional ingredients that the user will add later on
    // if (recipeInstance === undefined) {
    //   throw Error("Cannot compute recipe proportions " + "if there's no recipe instance.");
    // }
    // how many ingredients are there
    for (let i = 0; i < this.coreInstance.ingredients.length; i++) {
      const ingredientInstance = this.coreInstance.ingredients[i];
      const ingredient = ingredientInstance.ingredient;
      // la proporzione del singolo ingrediente è data dalla sua quantita
      // rispetto alla quantità totale
      const proportion = ingredientInstance.quantity / this.coreInstance.totIngredients;

      ingredient._setProportion(proportion);
      ingredient._setPercentage(proportion);
    }
    return this;
  }

  _findProportionOfIngredient(ingredientName) {
    for (let i = 0; i < this.ingredients.length; i++) {
      const ingredient = this.ingredients[i];
      // se trovo l'ingrediente che mi interessa
      if (ingredient.name === ingredientName) {
        return ingredient.proportion;
      }
    }
    throw Error("Non è stato trovato nessuna proporzione per l'ingrediente dato.");
  }
}

class RecipeInstance {
  constructor(ingredientsList, recipe) {
    // this.recipe = recipe;
    this.ingredients = [];
    this.totIngredients = 0;
    this.addIngredients(ingredientsList, recipe);
  }

  addIngredients(ingredientsList, recipe) {
    for (let i = 0; i < ingredientsList.length; i++) {
      const ingredientInfo = ingredientsList[i];
      const ingredient = recipe.ingredients[i];
      this.addIngredient(ingredientInfo, ingredient);
    }
  }

  addIngredient(ingredientInfo, ingredient) {
    const ingredientInstance = new IngredientInstance(ingredientInfo, ingredient, this);
    this.ingredients.push(ingredientInstance);
    this.totIngredients += ingredientInstance.quantity;
    return ingredientInstance;
  }

  calcTotIngredients() {
    this.totIngredients = 0;
    for (let i = 0; i < this.ingredients.length; i++) {
      const ingredientInstance = this.ingredients[i];
      this.totIngredients += ingredientInstance.quantity;
    }
    return this;
  }
}

class Ingredient {
  constructor(info) {
    this.name = info.name;
    this.proportion = info.proportion;
  }

  getProportion() {
    return this.proportion;
  }

  getProportionRounded() {
    return this._roundProportion(this.proportion);
  }

  getPercentage() {
    return this.proportion * 100;
  }

  getPercentageRounded() {
    return this._roundPercentage(this.proportion * 100);
  }

  _setProportion(proportion) {
    this.proportion = proportion;
  }

  _setPercentage(proportion) {
    this.percentage = proportion * 100;
  }

  // HELPERS

  _roundNumber(x, nDigits) {
    return parseFloat(x.toFixed(nDigits));
  }

  _roundProportion(x) {
    return this._roundNumber(x, 4);
  }

  _roundPercentage(x) {
    return this._roundNumber(x, 2);
  }

  _roundQuantity(x) {
    return this._roundNumber(x, 2);
  }

  genRandNum(limit = 10000000) {
    return Math.floor(Math.random() * limit);
  }
}

class IngredientInstance {
  constructor(info, ingredient, recipeInstance) {
    this.quantity = info.quantity;
    this.ingredient = ingredient;
    this.recipeInstance = recipeInstance;
  }
}

// USAGE

const myRecipe = new Recipe("My Recipe", [
  { name: "water", quantity: 900 },
  { name: "wheat", quantity: 100 },
]);

myRecipe.addIngredient({
  name: "salt",
  quantity: 10,
});

myRecipe.removeIngredient("salt");

console.log(myRecipe);

// the actual recipe
// const recipeFatimasBread = new Recipe("Fatima's Bread", [
//   { name: "farina v300", quantity: 430 },
//   { name: "farina semola", quantity: 20 },
//   { name: "acqua", quantity: 315 },
//   { name: "olio", quantity: 15 },
//   { name: "sale", quantity: 15 },
//   { name: "malto", quantity: 6 },
//   { name: "zucchero", quantity: 6 },
//   { name: "lievito birra", quantity: 1 },
// ]);

// recipeFatimasBread.addIngredient({
//   name: "malto2",
//   quantity: 4,
// });

// recipeFatimasBread.removeIngredient("malto2");

// recipe instance
// const recipeFatimasBreadFromXWheat = recipeFatimasBread.calcFromIngredient({
//   name: "farina v300",
//   quantity: 800,
// });

// recipe instance
// const recipeFatimasBreadFromXTot = recipeFatimasBread.calcFromTot(1000);

// console.log(recipeFatimasBread);
// console.log(recipeFatimasBreadFromXWheat);
// console.log(recipeFatimasBreadFromXTot);
